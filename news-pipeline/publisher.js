#!/usr/bin/env node
/**
 * Publisher - Publishes approved content to social media
 *
 * Checks for approved articles in the review queue and publishes them.
 * Integrates with existing twitter-curator infrastructure.
 */

require('dotenv').config({ path: require('path').join(__dirname, '..', '.env') });

const fs = require('fs');
const path = require('path');
const { execSync } = require('child_process');

// Import standalone tweet posting
let postTweet;
try {
  postTweet = require('./post-tweet').postTweet;
} catch (err) {
  console.log('âš ï¸ post-tweet module not available');
}

// Load configuration
const CONFIG_PATH = path.join(__dirname, 'feeds.json');
const config = JSON.parse(fs.readFileSync(CONFIG_PATH, 'utf8'));

// Published articles log
const PUBLISHED_LOG = path.join(__dirname, 'published.json');

// Notification helper
function notify(title, message) {
  try {
    execSync(`osascript -e 'display notification "${message}" with title "${title}"'`);
  } catch (err) {
    // Ignore notification errors
  }
}

// Parse frontmatter from markdown
function parseFrontmatter(content) {
  const match = content.match(/^---\n([\s\S]*?)\n---/);
  if (!match) return null;

  const frontmatter = {};
  const lines = match[1].split('\n');

  for (const line of lines) {
    const colonIndex = line.indexOf(':');
    if (colonIndex > 0) {
      const key = line.substring(0, colonIndex).trim();
      let value = line.substring(colonIndex + 1).trim();

      // Remove quotes
      if (value.startsWith('"') && value.endsWith('"')) {
        value = value.slice(1, -1);
      }

      frontmatter[key] = value;
    }
  }

  return frontmatter;
}

// Extract content to publish
function extractContent(markdown) {
  // First try "Your Version" section (both ## and ### formats)
  const yourVersionMatch = markdown.match(/##+ Your Version[^`]*```\n([\s\S]*?)\n```/);
  if (yourVersionMatch && yourVersionMatch[1].trim()) {
    return yourVersionMatch[1].trim();
  }

  // Fall back to AI Draft (### AI Draft from new template)
  const aiDraftMatch = markdown.match(/### AI Draft[^`]*```\n([\s\S]*?)\n```/);
  if (aiDraftMatch && aiDraftMatch[1].trim()) {
    return aiDraftMatch[1].trim();
  }

  // Fall back to Draft Tweet (## Draft Tweet from old format)
  const draftTweetMatch = markdown.match(/## Draft Tweet[^`]*```\n([\s\S]*?)\n```/);
  if (draftTweetMatch && draftTweetMatch[1].trim()) {
    return draftTweetMatch[1].trim();
  }

  return null;
}

// ðŸ†• 2026-02-11: Content sanitizer - prevent leaks and automation exposure
// Shared with Apollo for consistent safety across both systems
function sanitizeContent(text, platform = 'twitter') {
  if (!text || typeof text !== 'string') {
    return null;
  }

  let cleaned = text.trim();

  // Banned patterns that indicate leaked prompts, system instructions, or automation
  const BANNED_PATTERNS = [
    // AI response prefixes (leaked prompts) - check BEFORE cleaning
    /^(Here's|Here is|I'll write|I will write|Let me write|Below is|This is)\b/i,
    // System/agent names (internal architecture)
    /\b(Apollo|Hermes|MAGI|Melchior|Balthasar|Casper|Iris|Lucy|Leo)\b/g,
    // Automation exposure
    /\b(automated?|auto-generat(e|ed|ing)|content generation|AI draft|generated by|scheduled tweets?|content calendar)\b/gi,
    // Prompt instructions leaked
    /\b(Make sure to|Ensure|Avoid mentioning|Use .* perspective|Call to action)\b/i,
    // Technical stack (backend infrastructure)
    /\b(CLIProxy|CLIProxyAPI|Gemini|gpt-oss|Ollama|Puppeteer|Playwright)\b/g,
    // Meta-commentary about the content itself
    /^(The following|This post|This content|Draft|Version)\b/i
  ];

  // First check for banned patterns BEFORE any cleaning
  for (const pattern of BANNED_PATTERNS) {
    if (pattern.test(cleaned)) {
      const match = cleaned.match(pattern);
      console.error(`\nâ›” PUBLISH BLOCKED - Forbidden content detected:`);
      console.error(`   Pattern: ${pattern}`);
      console.error(`   Matched: "${match ? match[0] : 'unknown'}"`);
      console.error(`   Preview: "${cleaned.substring(0, 150)}..."\n`);
      return null;
    }
  }

  // If passed banned patterns check, apply cleaning
  // Remove common AI response wrapper patterns
  // e.g., "Here's the corrected post:\n\n[actual content]"
  cleaned = cleaned.replace(/^.*?:?\s*\n\n/s, (match) => {
    // Only remove if it looks like a meta-commentary prefix
    const metaPrefixes = ['here', 'below', 'following', 'draft', 'version', 'write'];
    const startsWithMeta = metaPrefixes.some(prefix =>
      match.toLowerCase().trim().startsWith(prefix)
    );
    return startsWithMeta ? '' : match;
  });

  // Remove quotes if entire content is wrapped (common AI pattern)
  if (cleaned.startsWith('"') && cleaned.endsWith('"')) {
    cleaned = cleaned.slice(1, -1).trim();
  }

  // Platform-specific validation
  if (platform === 'twitter') {
    if (cleaned.length > 280) {
      console.error(`â›” PUBLISH BLOCKED - Tweet exceeds 280 chars (${cleaned.length})`);
      return null;
    }
  } else if (platform === 'linkedin') {
    if (cleaned.length > 2500) {
      console.warn(`âš ï¸  LinkedIn post is long (${cleaned.length} chars). Consider trimming.`);
    }
  }

  return cleaned;
}

// Check if it's time to publish
function shouldPublishNow(publishAt) {
  if (!publishAt || publishAt === 'now') {
    return true;
  }

  try {
    const publishTime = new Date(publishAt);
    return Date.now() >= publishTime.getTime();
  } catch (err) {
    return false;
  }
}

// Publish to Twitter using Puppeteer
async function publishToTwitter(content, sourceUrl) {
  console.log('  ðŸ“¤ Publishing to Twitter...');

  // ðŸ†• 2026-02-11: Sanitize content before publishing
  const sanitized = sanitizeContent(content, 'twitter');
  if (!sanitized) {
    console.error('  â›” PUBLISH BLOCKED: Content failed sanitization checks');
    // Log the blocked attempt for audit
    const auditLog = {
      blocked: true,
      reason: 'Failed sanitization',
      platform: 'twitter',
      original: content,
      sourceUrl: sourceUrl,
      timestamp: new Date().toISOString()
    };
    const auditPath = path.join(__dirname, 'publish-audit.log');
    fs.appendFileSync(auditPath, JSON.stringify(auditLog) + '\n');
    return false;
  }

  // Show sanitized preview
  console.log(`  Preview: "${sanitized.substring(0, 60)}..." (${sanitized.length} chars)`);

  // Check if posting module is available
  if (!postTweet) {
    console.log('  âš ï¸ Post module not available, creating task file instead');

    // Fallback: create task file for manual execution
    const taskPath = path.join(__dirname, 'twitter-task.json');
    const task = {
      type: 'post',
      content: sanitized,
      sourceUrl: sourceUrl,
      timestamp: new Date().toISOString()
    };
    fs.writeFileSync(taskPath, JSON.stringify(task, null, 2));
    console.log('  ðŸ“ Task file created for manual posting');
    return true;
  }

  try {
    // Use Puppeteer to post directly
    console.log('  ðŸŽ­ Using Puppeteer to post...');
    const result = await postTweet(sanitized);

    if (result.success) {
      console.log('  âœ… Tweet posted successfully!');
      if (result.url) {
        console.log(`  ðŸ”— ${result.url}`);
      }
      return true;
    } else {
      console.log(`  âŒ Posting failed: ${result.error}`);
      return false;
    }
  } catch (err) {
    console.error('  âŒ Twitter publish error:', err.message);
    return false;
  }
}

// Update file status after publishing
function updateFileStatus(filepath, newStatus) {
  let content = fs.readFileSync(filepath, 'utf8');

  // Update status in frontmatter
  content = content.replace(/^status: \w+$/m, `status: ${newStatus}`);

  // Add published timestamp
  if (newStatus === 'published') {
    content = content.replace(
      /^publish_at:.*$/m,
      `publish_at: ${new Date().toISOString()}\npublished_at: ${new Date().toISOString()}`
    );
  }

  fs.writeFileSync(filepath, content);
}

// Log published article
function logPublished(article) {
  let log = [];
  if (fs.existsSync(PUBLISHED_LOG)) {
    log = JSON.parse(fs.readFileSync(PUBLISHED_LOG, 'utf8'));
  }

  log.push({
    ...article,
    publishedAt: new Date().toISOString()
  });

  // Keep last 100 entries
  if (log.length > 100) {
    log = log.slice(-100);
  }

  fs.writeFileSync(PUBLISHED_LOG, JSON.stringify(log, null, 2));
}

// Move file to published folder
function moveToPublished(filepath) {
  const publishedDir = path.join(config.paths.queueDir, '..', 'content-published');
  if (!fs.existsSync(publishedDir)) {
    fs.mkdirSync(publishedDir, { recursive: true });
  }

  const filename = path.basename(filepath);
  const newPath = path.join(publishedDir, filename);

  fs.renameSync(filepath, newPath);
  return newPath;
}

// Main publish function
async function publishApproved() {
  console.log('â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—');
  console.log('â•‘         Content Publisher v1.0             â•‘');
  console.log('â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
  console.log(`\nTime: ${new Date().toISOString()}\n`);

  const queueDir = config.paths.queueDir;

  if (!fs.existsSync(queueDir)) {
    console.log('Queue directory not found');
    return { published: 0, scheduled: 0 };
  }

  const files = fs.readdirSync(queueDir).filter(f => f.endsWith('.md'));
  console.log(`Files in queue: ${files.length}\n`);

  let published = 0;
  let scheduled = 0;
  let rejected = 0;

  for (const file of files) {
    const filepath = path.join(queueDir, file);
    const content = fs.readFileSync(filepath, 'utf8');
    const frontmatter = parseFrontmatter(content);

    if (!frontmatter) continue;

    console.log(`ðŸ“„ ${file}`);
    console.log(`   Status: ${frontmatter.status}`);

    if (frontmatter.status === 'approved') {
      const publishAt = frontmatter.publish_at;

      if (shouldPublishNow(publishAt)) {
        console.log('   â° Ready to publish');

        const tweetContent = extractContent(content);
        if (!tweetContent) {
          console.log('   âš ï¸ No content to publish, skipping');
          continue;
        }

        console.log(`   ðŸ“ Content: ${tweetContent.substring(0, 60)}...`);

        // Publish to Twitter
        const twitterSuccess = await publishToTwitter(tweetContent, frontmatter.url);

        if (twitterSuccess) {
          // Update status and move file
          updateFileStatus(filepath, 'published');
          const newPath = moveToPublished(filepath);

          logPublished({
            file,
            title: frontmatter.title,
            content: tweetContent,
            url: frontmatter.url,
            platforms: ['twitter']
          });

          console.log(`   âœ… Published and moved to content-published/`);
          published++;
        }
      } else {
        console.log(`   â³ Scheduled for: ${publishAt}`);
        scheduled++;
      }
    } else if (frontmatter.status === 'rejected') {
      // Move rejected files to archive
      const archivePath = path.join(config.paths.archiveDir, file);
      fs.renameSync(filepath, archivePath);
      console.log('   ðŸ—‘ï¸ Moved to archive');
      rejected++;
    } else {
      console.log('   â¸ï¸ Pending review');
    }

    console.log('');
  }

  console.log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
  console.log(`Published: ${published}`);
  console.log(`Scheduled: ${scheduled}`);
  console.log(`Rejected: ${rejected}`);
  console.log(`Pending: ${files.length - published - scheduled - rejected}`);

  if (published > 0) {
    notify('Content Publisher', `${published} article(s) published`);
  }

  return { published, scheduled, rejected };
}

// Run if called directly
if (require.main === module) {
  publishApproved().catch(console.error);
}

module.exports = {
  publishApproved,
  parseFrontmatter,
  extractContent,
  sanitizeContent  // ðŸ†• 2026-02-11: Export for testing and other modules
};
